import os
import sys

# setup up mavlink
os.environ["MAVLINK20"] = "1"  # force MAVLink v2 for the moment
sys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)), "mavlink"))
from pymavlink import mavutil  # noqa: E402


def auto_gen_message(fid):
    message = "// This file is automatically generated, do not edit\n"
    fid.write(message)


def get_c_field_types(mavmap):
    mavlink_headders_base = os.path.join(os.getcwd(), 'generated', 'mavlink')
    subfolders = [f.path for f in os.scandir(mavlink_headders_base) if f.is_dir() ]
    print(subfolders)
    for msg_type in mavmap.keys():
        msg_name = mavmap[msg_type].name
        mavmap[msg_type].types = {}
        for folder in subfolders:
            file_path = os.path.join(folder, 'mavlink_msg_{name_lower}.h'.format(name_lower=msg_name.lower()))
            if os.path.isfile(file_path):
                with open(file_path, 'r+') as fid:
                    for line in fid:
                        if "MAVPACKED(" in line:
                            fid.readline()
                            exit = False
                            while not exit:
                                line = fid.readline()
                                if "}) mavlink" in line:
                                    exit = True
                                else:
                                    line = line.strip()
                                    line = line.split(' ')
                                    field_type = line[0]
                                    field_name = line[1].rstrip(';').rstrip(']').split('[')
                                    if len(field_name) == 2:
                                        array_size = field_name[1]
                                        field_name = field_name[0]
                                    else:
                                        array_size = 0
                                        field_name = field_name[0]
                                    mavmap[msg_type].types[field_name] = {'type':field_type, 'array_size':int(array_size)}
    return mavmap


def generate_imports(fid):
    imports = """
#include <list>
#include <map>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>
#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <mavlink/ardupilotmega/mavlink.h>"""

    pybind_setup = """

namespace py = pybind11;
py::module json = py::module::import("json");
py::object dumps = json.attr("dumps");"""

    helper_functions = """

// trim srting from end (in place)
static inline void rtrim(std::string &s) {
    s.erase(std::find_if(s.rbegin(), s.rend(), [](int ch) {
        if (ch == '\0') {
            return false;
        }
        else if (std::isspace(ch)) {
            return false;
        }
        else {
            return true;
        }
    }).base(), s.end());
}"""

    fid.write(imports)
    fid.write(pybind_setup)
    fid.write(helper_functions)


def generate_mavlink_headder_class(fid):
    mavlink_headder = """

class MAVLink_header {
public:
    MAVLink_header(uint32_t msgId, uint8_t incompat_flags, uint8_t compat_flags, uint8_t mlen, uint8_t _seq, uint8_t srcSystem, uint8_t srcComponent): msgId(msgId),
    mlen(mlen), seq(_seq), srcSystem(srcSystem), srcComponent(srcComponent), incompat_flags(incompat_flags), compat_flags(compat_flags){ }
    ~MAVLink_header() { }
    uint8_t mlen;
    uint8_t seq;
    uint8_t srcSystem;
    uint8_t srcComponent;
    uint32_t msgId;
    uint8_t incompat_flags;
    uint8_t compat_flags;
};"""
    fid.write(mavlink_headder)


def generate_mavlink_message_class(fid):
    mavlink_message = """

class MAVLink_message {
public:
    MAVLink_message(std::string name, uint32_t msgId, uint8_t incompat_flags, uint8_t compat_flags, uint8_t mlen, uint8_t _seq, uint8_t srcSystem, uint8_t srcComponent) : _type(name),
    _header(MAVLink_header(msgId, incompat_flags, compat_flags, mlen, _seq, srcSystem, srcComponent)) {
        _link_id = 0;
        _signed = false;
    }
    virtual ~MAVLink_message(){};
    inline const std::string get_type(void) {return _type;}
    inline const std::string str(void) {return _stream.str();}
    inline const uint8_t get_srcComponent(void) {return _header.srcComponent;}
    inline const uint8_t get_srcSystem(void) {return _header.srcSystem;}
    inline const uint8_t get_seq(void) {return _header.seq;}
    inline const bool get_signed(void) {return _signed;}
    inline const uint32_t get_msgId(void) {return _header.msgId;}
    inline const py::dict to_dict(void) {return _dict;}
    inline const py::str to_json(void) {return dumps(_dict);}
    std::string _type;
    bool _signed;
    int _link_id;
    MAVLink_header _header;
    py::dict _dict;
    std::ostringstream _stream;
    std::vector<std::string> _fieldnames;
};"""
    fid.write(mavlink_message)


def generate_mavlink_message_types(fid, mavmap):
    for msg_type in mavmap.keys():
        msg_name = mavmap[msg_type].name

        mavlink_message_class = """
class MAVLink_{name_lower}_message : public MAVLink_message {{
public:
    MAVLink_{name_lower}_message(uint32_t msgId, uint8_t incompat_flags, uint8_t compat_flags, uint8_t mlen, uint8_t _seq, uint8_t srcSystem, uint8_t srcComponent, """.format(name_lower=msg_name.lower())
        fid.write(mavlink_message_class)
        end = None
        for field in mavmap[msg_type].fieldnames:
            if end:
                fid.write(', ')
            array_size = mavmap[msg_type].types[field]['array_size']
            if array_size:
                fid.write('std::vector<{t}> {f}'.format(t=mavmap[msg_type].types[field]['type'], f=field))
            else:
                fid.write('{t} {f}'.format(t=mavmap[msg_type].types[field]['type'], f=field))
            end = True
        fid.write(') :\n')
        fid.write('        MAVLink_message("{name_upper}", msgId, incompat_flags, compat_flags, mlen, _seq, srcSystem, srcComponent) {{\n'.format(name_upper=msg_name.upper()))
        for field in mavmap[msg_type].fieldnames:
            if ((mavmap[msg_type].types[field]['array_size'] != 0) and (mavmap[msg_type].types[field]['type'] == 'char')):
                fid.write('        _{f} = {f};\n'.format(f=field))
                fid.write('        std::string {f}_s({f}.begin(),{f}.end());\n'.format(f=field))
                fid.write('        rtrim({f}_s);\n'.format(f=field))
            else:
                fid.write('        {f} = {f};\n'.format(f=field))
        fid.write('        _fieldnames = {')
        end = None
        for field in mavmap[msg_type].fieldnames:
            if end:
                fid.write(', ')
            fid.write('"{f}"'.format(f=field))
            end = True
        fid.write('};\n')
        fid.write('        _dict["mavpackettype"] = _type;\n')
        for field in mavmap[msg_type].fieldnames:
            if ((mavmap[msg_type].types[field]['array_size'] != 0) and (mavmap[msg_type].types[field]['type'] == 'char')):
                fid.write('        _dict["{f}"] = {f}_s;\n'.format(f=field))
            else:
                fid.write('        _dict["{f}"] = {f};\n'.format(f=field))
        fid.write('       _stream  << _type;')
#             _stream  << _type << " {" << "type : " << std::to_string(type) <<", "<< "autopilot : "<< std::to_string(autopilot) <<", "<< "base_mode : " << std::to_string(base_mode) << ", " << "custom_mode : "<< std::to_string(custom_mode) <<", "<< "system_status : " << std::to_string(system_status) << ", " << "mavlink_version : "<< std::to_string(mavlink_version) << "}";
        fid.write('    }\n')
        fid.write('    ~MAVLink_{name_lower}_message() {{ }}\n'.format(name_lower=msg_name.lower()))
        for field in mavmap[msg_type].fieldnames:
            array_size = mavmap[msg_type].types[field]['array_size']
            field_type = mavmap[msg_type].types[field]['type']
            if ((array_size != 0) and (field_type == 'char')):
                fid.write('    std::vector<{t}> _{f};\n'.format(t=mavmap[msg_type].types[field]['type'], f=field))
                fid.write('    std::string {f}_s;\n'.format(t=mavmap[msg_type].types[field]['type'], f=field))
            elif array_size:
                fid.write('    std::vector<{t}> {f};\n'.format(t=mavmap[msg_type].types[field]['type'], f=field))
            else:
                fid.write('    {t} {f};\n'.format(t=mavmap[msg_type].types[field]['type'], f=field))
        fid.write('};')


def generate_mavlink_parser_class(fid, mavmap):
    mavlink_parser_class = """

class MAVLink_parser {
public:
    MAVLink_parser(){}
    ~MAVLink_parser(){}

    mavlink_status_t status;

    auto parse_char(std::string a) {
        mavlink_message_t msg;
        for(char& c : a) {
            if(mavlink_parse_char(0,c,&msg,&status)) {"""
    fid.write(mavlink_parser_class)
    generate_switch_statement(mavmap, fid)
    mavlink_parser_class = """
            }
        }
        py::object ret = py::none();
        return ret;
    };
};"""
    fid.write(mavlink_parser_class)


def generate_switch_statement(mavmap, fid):
    preamble = """
                switch(msg.msgid) {"""
    fid.write(preamble)
    for msg_type in mavmap.keys():
#         print(mavmap[msg_type].fieldnames)
        msg_name = mavmap[msg_type].name
        case_start = """
                    case MAVLINK_MSG_ID_{name}: {{
                        mavlink_{name_lower}_t {name_lower};
                        mavlink_msg_{name_lower}_decode(&msg, &{name_lower});
                        py::object ret = py::cast(""".format(
                        name=msg_name, name_lower=msg_name.lower()
                    )
#         print(case_start)
        fid.write(case_start)
        case = """
                            new MAVLink_{name_lower}_message(
                                msg.msgid, msg.incompat_flags, msg.compat_flags, msg.len, msg.seq, msg.sysid, msg.compid,\n""".format(
                name_lower=msg_name.lower()
            )
        fid.write(case)
        end = None
        for field in mavmap[msg_type].fieldnames:
            if end:
                fid.write(',\n')
            array_size = mavmap[msg_type].types[field]['array_size']
            if array_size:
                fid.write('                                std::vector<{t}>({name_lower}.{field}, {name_lower}.{field} + {array_size})'.format(t=mavmap[msg_type].types[field]['type'], name_lower=msg_name.lower(), field=field, array_size=array_size))
            else:
                fid.write('                                {name_lower}.{field}'.format(
                name_lower=msg_name.lower(), field=field))
            end = True
        case_end = """
                            )
                        );
                        return ret;
                    }"""
        fid.write(case_end)
    postamble = """
                    default: {
                        break;
                    }
                }"""
    fid.write(postamble)


def generate_pybind_code(fid, mavmap):
    pybind_static_code = """

PYBIND11_MODULE(MAVLink_binder, m) {

    py::class_<MAVLink_parser>(m, "MAVLink_parser")
        .def(py::init<>())
        .def("parse_char", &MAVLink_parser::parse_char);

    py::class_<MAVLink_header>(m, "MAVLink_header", py::dynamic_attr())
        .def(py::init<uint32_t, uint8_t, uint8_t, uint8_t, uint8_t, uint8_t, uint8_t>())
        .def_readwrite("srcSystem", &MAVLink_header::srcSystem)
        .def_readwrite("srcComponent", &MAVLink_header::srcComponent)
        .def_readwrite("msgId", &MAVLink_header::msgId);

    py::class_<MAVLink_message>(m, "MAVLink_message", py::dynamic_attr())
        .def(py::init<std::string, uint32_t, uint8_t, uint8_t, uint8_t, uint8_t, uint8_t, uint8_t>())
        .def_readwrite("_header", &MAVLink_message::_header)
        .def_readwrite("_type", &MAVLink_message::_type)
        .def_readwrite("_fieldnames", &MAVLink_message::_fieldnames)
        .def("__str__", &MAVLink_message::str)
        .def("get_type", &MAVLink_message::get_type)
        .def("get_srcComponent", &MAVLink_message::get_srcComponent)
        .def("get_srcSystem", &MAVLink_message::get_srcSystem)
        .def("get_seq", &MAVLink_message::get_seq)
        .def("get_signed", &MAVLink_message::get_signed)
        .def("get_msgId", &MAVLink_message::get_msgId)
        .def("to_dict", &MAVLink_message::to_dict)
        .def("to_json", &MAVLink_message::to_json);"""

    fid.write(pybind_static_code)
    for msg_type in mavmap.keys():
        msg_name = mavmap[msg_type].name
        pybind_dynamic_code = """
    py::class_<MAVLink_{name_lower}_message, MAVLink_message>(m, "MAVLink_{name_lower}_message", py::dynamic_attr())\n""".format(name_lower=msg_name.lower())
        fid.write(pybind_dynamic_code)
        fid.write('        .def(py::init<uint32_t, uint8_t, uint8_t, uint8_t, uint8_t, uint8_t, uint8_t, ')
        end = None
        for field in mavmap[msg_type].fieldnames:
            if end:
                fid.write(', ')
            array_size = mavmap[msg_type].types[field]['array_size']
            if array_size:
                fid.write('std::vector<{t}>'.format(t=mavmap[msg_type].types[field]['type']))
            else:
                fid.write(mavmap[msg_type].types[field]['type'])
            end = True
        fid.write('>())\n')
        end = None
        for field in mavmap[msg_type].fieldnames:
            if end:
                fid.write('\n')
            array_size = mavmap[msg_type].types[field]['array_size']
            field_type = mavmap[msg_type].types[field]['type']
            if ((array_size != 0) and (field_type == 'char')):
                fid.write('        .def_readwrite("{field}", &MAVLink_{name_lower}_message::{field}_s)'.format(name_lower=msg_name.lower(), field=field))
            else:
                fid.write('        .def_readwrite("{field}", &MAVLink_{name_lower}_message::{field})'.format(name_lower=msg_name.lower(), field=field))
            end = True
        fid.write(';\n')
    fid.write("}")


def generate():
    mavmap = mavutil.mavlink.mavlink_map
    # contains a dict of all the message types and the fields
    mavmap = get_c_field_types(mavmap)

    # mavmap = {11011:mavmap[11011]}  # 41, 0, 186, 11011

    # print(mavmap[1].fieldnames)
    binding_code_file_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'src', 'mavlink_bindings.cpp')
    print(binding_code_file_path)
    with open(binding_code_file_path, 'w+') as fid:
        auto_gen_message(fid)
        generate_imports(fid)
        generate_mavlink_headder_class(fid)
        generate_mavlink_message_class(fid)
        generate_mavlink_message_types(fid, mavmap)
        generate_mavlink_parser_class(fid, mavmap)
    #     generate_switch_statement(mavmap, fid)
        generate_pybind_code(fid, mavmap)

# we need to generate binding code for all of the python types


if __name__ == '__main__':
    generate()

